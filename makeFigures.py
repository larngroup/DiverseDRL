# -*- coding: utf-8 -*-
"""
Created on Thu Feb  6 09:46:15 2020

@author: Tiago
"""
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import csv
from rdkit import Chem
from rdkit.Chem import Crippen
from rdkit.Chem import Descriptors as desc
from rdkit.Chem import QED
from utils import reading_csv,load_config,generate2file,smiles2mol
from tokens import tokens_table
from sascorer_calculator import SAscore
from prediction import Predictor
from keras.models import Sequential
from model import Model 

colors = ['#ff7f0e', '#1f77b4', '#d62728', '#2ca02c', '#9467bd']  # orange, blue, green, red, purple
           
def properties_violin(filepaths,labels,pred_type):
    """
    Function that extracts a pd dataframe with QED, pIC50, and SAscore from the
    specified filepaths.
    """
    properties = []
      
    for i,fname in enumerate(filepaths):
        with open(filepaths[i], 'r') as f:
            reader = csv.reader(f)
        
            it = iter(reader)
#            next(it, None)  # skip first item.    
            for row in it:
                    if pred_type == 'pIC50':
                        properties.append([labels[i],'pIC50 for KOR',float(row[1])]) 
                    if i != 0:
                        properties.append([labels[i],'SA score',float(row[2])])
                        try:
                            mol = Chem.MolFromSmiles(row[0])
                            q = QED.qed(mol)
    #                        x, y = desc.MolWt(mol), Crippen.MolLogP(mol)
    #                        properties.append([labels[i],'Molecular weight',x])
    #                        properties.append([labels[i],'logP',y])
                            properties.append([labels[i],'QED',q])
                            
                        except: 
                            print("Non-Canonical SMILES: " + row[0])
                    else:
                        
                        try:
                            mole = smiles2mol(row[0])
                            prediction_sas = SAscore(mole)
                            properties.append([labels[i],'SA score',float(prediction_sas[0])])
                            mol = Chem.MolFromSmiles(row[0])
                            q = QED.qed(mol)
    #                        x, y = desc.MolWt(mol), Crippen.MolLogP(mol)
    #                        properties.append([labels[i],'Molecular weight',x])
    #                        properties.append([labels[i],'logP',y])
                            properties.append([labels[i],'QED',q])
                        except: 
                            print("Non-Canonical SMILES: " + row[0])
                    
    df = pd.DataFrame(properties, columns=['Sets', 'Property', 'Value'])
    return df

def properties_mw_logp(filepaths): 
    """
    Function used to extract a pd dataframe with MW and logP from the specified 
    filepaths.
    """   
    properties = []
      
    for i,fname in enumerate(filepaths):
        with open(filepaths[i], 'r') as f:
            reader = csv.reader(f)
        
            it = iter(reader)
            if not ("generated" in fname):
                for row in it:
                    try:
                        properties.append([float(row[2]),float(row[3]),i])
                    except:
                        print("")
            else:
                for row in it:
                    try:
                        mol = Chem.MolFromSmiles(row[0])
                        x, y = desc.MolWt(mol), Crippen.MolLogP(mol)
                        properties.append([x,y,i])
                    except: 
                        print("Non-Canonical SMILES: " + row[0])

    df = pd.DataFrame(properties[2000:2355], columns=['MW', 'logP', 'Label'])
    return df


def violin_plot(pred_identifier):
    """ 
    Function that graphs a violin plot for the physicochemical properties comparison.
    It compares molecules generated by unbiased and optimized models
    """
    config_file = 'configReinforce.json' 
    configReinforce,exp_time=load_config(config_file)
    
    if pred_identifier == 'pIC50':
         # Load the predictor model
        predictor = Predictor(configReinforce,'kor')
    else:
        predictor = None
    
    biased_generator = Sequential()
    biased_generator = Model(configReinforce)
    unbiased_generator = Sequential()
    unbiased_generator = Model(configReinforce)
    biased_generator.model.load_weights(configReinforce.model_name_biased+".h5")
    unbiased_generator.model.load_weights(configReinforce.model_name_unbiased)

    # generate with unbiased
    generate2file(predictor,unbiased_generator,configReinforce,5000,True)
    generate2file(predictor,biased_generator,configReinforce,5000,False)
#     
    plt.figure(figsize=(15, 5))

    sns.set(rc={"axes.facecolor":"white",
            "axes.grid":False,
            'axes.labelsize':20,
            'figure.figsize':(20.0, 10.0),
            'xtick.labelsize':15,
            'ytick.labelsize':15})
    
#    sns.set(style="white", palette="colorblind", color_codes=True)
    df = properties_violin(['Generated/smiles_prop_original.smi','Generated/smiles_prop_biased.smi'], ['Original generator', 'Fine-tuned generator'],pred_identifier)
    sns.violinplot(x='Property', y='Value', hue='Sets', data=df, linewidth=1, split=True, bw=1, legend = False)
    sns.despine(left=True)
    plt.ylim([-3, 15])
#    viol_plot.ax.legend(loc=2)

def mw_logp_plot():  
    """
    Function that graphs a chemical space comparison based on logP ~ MW
    """
    fig = plt.figure(figsize=(12, 12))
    lab = ['Chembl Dataset', 'Fine-tuned dataset']
    ax1 = fig.add_subplot(221)
    df = properties_mw_logp(['data/tyk_clean.csv', 'data/generated.smi'])

    group0, group1 = df[df.Label == 0], df[df.Label== 1]
    ax1.scatter(group0.MW, group0.logP, s=10, marker='o', label=lab[0], c='', edgecolor=colors[1])
    ax1.scatter(group1.MW, group1.logP, s=10, marker='o', label=lab[1], c='', edgecolor=colors[3])
    ax1.set(ylabel='LogP', xlabel='Molecular Weight')
    ax1.legend(loc='lower right')

    
def performance_barplot():
    """
    Function that graphs two bar plots with the QSAR model metrics (MSE and Q2)
    """
    objects = ('RNN', 'SVM', 'RF', 'KNN')
    y_pos = np.arange(len(objects))
    performance_mse = [0.0299,0.0531,0.0524,0.0566]
    
    plt.bar(y_pos, performance_mse, align='center', alpha=0.5, color=['blue' ,'yellow', 'green','red'],  edgecolor='black')
    plt.xticks(y_pos, objects)
    plt.ylabel('MSE')
    plt.title('QSAR models evaluation: Mean Squared Error')
    plt.show()
    

    y_pos = np.arange(len(objects))
    performance_r2 = [71.4,57.0,57.6,54.1]
    
    plt.bar(y_pos, performance_r2, align='center', alpha=0.5, color=['blue' ,'yellow', 'green','red'],  edgecolor='black')

    plt.xticks(y_pos, objects)
    plt.ylabel('Q2 Score')
    plt.title('QSAR models evaluation: R-squared')
    plt.show()

def regression_plot(y_true,y_pred):
    """
    Function that graphs a scatter plot and the respective regression line to 
    evaluate the QSAR models.
    Parameters
    ----------
    y_true: True values from the label
    y_pred: Predictions obtained from the model
    Returns
    -------
    This function returns a scatter plot.
    """
    fig, ax = plt.subplots()
    ax.scatter(y_true, y_pred)
    ax.plot([np.min(y_true), np.max(y_true)], [np.min(y_true), np.max(y_true)], 'k--', lw=4)
    ax.set_xlabel('True')
    ax.set_ylabel('Predicted')
    plt.show()
    
def main():
    """
    Main of function that plots several figures to help the interpretation of the 
    results obtained from both the Predictor and Generator.
    """
    predictor = 'pIC50' # pIC50 or sas          
    y_true = [1, 2, 3,4,5,2,2,1,3]
    y_pred = [1.1, 1.6, 3, 4.1, 4.5, 1.8, 2,1.6,3.1]
#    regression_plot(y_true,y_pred)
#    performance_barplot()
    violin_plot(predictor)
#    mw_logp_plot()

if __name__ == '__main__':
    main()